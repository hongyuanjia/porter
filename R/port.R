#' Parse C-family header files using CastXML and gather data from the generated
#' XML.
#'
#' @param header A single string indicating the path of C header file.
#'
#' @param limit A flag (`TRUE`/`FALSE`) or a character vector. If `TRUE`, only
#'        functions/enums/structs/unions from the directory of the input header
#'        are kept. If `FALSE`, no subsetting is performed. If a character
#'        vector, it should be paths of directories used to constrain the scope.
#'        Default: `FALSE`.
#'
#' @param keep Either `TRUE` or `FALSE`. If `TRUE`, the XML file generated by
#'        CastXML is saved into the same directory of input header file with the
#'        same name. Default: `FALSE`.
#'
#' @param cflags A character vector of C compile flags passed to CastXML.
#'        Default: `NULL`.
#'
#' @param castxml A single string indicating the file path of the CastXML
#'        executable. Default is used the path found by [locate_castxml()].
#'
#' @return A named list.
#'
#' @export
port <- function(header, limit = FALSE, keep = FALSE, cflags = NULL, castxml = locate_castxml()) {
    if (!is_string(castxml) || !file.exists(castxml)) {
        stop("Argument 'castxml' must be a file path of CastXML executable.")
    }
    if (!is_string(header) || !file.exists(header)) {
        stop("Argument 'header' must be a file path.")
    } else if (file_ext(header) %in% c("hpp", "hh")) {
        warning(paste0(
            "Argument 'header' seems to be a C++ header file",
            "which is currently not fully supported. Parsing errors may occur."
        ))
    }
    if (!is.null(cflags) && (!is.character(cflags) || any(is.na(cflags)))) {
        stop("Argument 'cflags' should be NULL or a character vector without missing values.")
    }
    if (!is_flag(limit) && (!is.character(limit) || any(is.na(limit)))) {
        stop("Argument 'limit' should be either TRUE/FALSE or a character vector of directories.")
    }
    if (!is_flag(keep)) {
        stop("Argument 'keep' should be either TRUE or FALSE.")
    }

    castxml <- normalizePath(castxml, mustWork = TRUE)
    out <- tempfile("porter-", fileext = ".xml")

    # run castxml and read the generated XML file
    proc <- system3(castxml, "--castxml-output=1", cflags, "-o", out, header, .capture = FALSE)
    if (proc != 0L || !file.exists(out)) {
        stop("CastXML errors. Please check input arguments, especially 'header' and 'cflags'.")
    }

    if (keep) {
        file.copy(out, sprintf("%s.xml", tools::file_path_sans_ext(header)))
    }

    # get the directories for headers to be included
    dirs <- NULL
    # only consider files in the same folder as the input header file
    if (is_flag(limit) && limit) {
        dirs <- dirname(header)
    } else if (any(is_dir <- file.info(limit)$isdir)) {
        dirs <- limit[is_dir]
    }
    data <- port_xml(out, dirs)

    data["file"] <- NULL
    data["type"] <- NULL

    # TODO: remove non-useful columns
    data
}

#' Extract data from the XML file generated by CastXML
#'
#' @param xml A path of an XML generated using CastXML. Both the
#'        `--castxml-output` and `--output-gccxml` options are supported.
#'
#' @param dirs A character of directories used to constrain the header files to
#'        extract the data. Default: `NULL`.
#'
#' @return A named list of six elements:
#'
#' - `func`: function data
#' - `enum`: enumeration data
#' - `struct`: struct data
#' - `union`: union data
#' - `type`: type data
#' - `file`: file data
#'
#' @keywords internal
#' @export
port_xml <- function(xml, dirs = NULL) {
    if (!"xml_document" %in% class(xml)) xml <- xml2::read_xml(xml)

    # check if the root is GCC_XML or CastXML
    if (!xml2::xml_name(xml2::xml_root(xml)) %in% c("GCC_XML", "CastXML")) {
        stop("Input XML should be generated using GCCXML or CastXML.")
    }

    # extract data from corresponding xml nodes
    files   <- proc_node_files(xml)
    fields  <- proc_node_fields(xml)
    types   <- proc_node_types(xml)
    funs    <- proc_node_funs(xml)
    enums   <- proc_node_enums(xml,   types)
    structs <- proc_node_structs(xml, types, fields)
    unions  <- proc_node_unions(xml,  types, fields)

    # merge all type data to create a full list of types
    types <- merge_all_types(types, enums, structs, unions, fields)

    # find base types for all function arguments and return values
    funs <- proc_type_funs(types, funs)

    # find base types for all struct/union members
    structs <- proc_type_structs(types, structs)
    unions  <- proc_type_unions(types, unions)

    # only consider files in the same folder as the input header file
    if (!is.null(dirs)) {
        dirs <- normalizePath(dirs, mustWork = FALSE)
        paths <- normalizePath(dirname(files$name), mustWork = FALSE)
        is_tar <- logical(length(paths))
        for (d in dirs) is_tar <- is_parent_dir(d, paths) | is_tar
        inclu <- files$id[is_tar & files$name != "<builtin>"]

        # no matched
        if (!length(inclu)) {
            out <- replicate(6, data.frame())
            names(out) <- c("func", "enum", "struct", "union", "type", "file")
            return(out)
        } else {
            subset_by_file <- function(df, files) {
                if (!is.null(df)) as_df(df[df$file %in% files, ])
            }
            funs    <- subset_by_file(funs,    inclu)
            enums   <- subset_by_file(enums,   inclu)
            structs <- subset_by_file(structs, inclu)
            unions  <- subset_by_file(unions,  inclu)
            files   <- subset_by_file(files,   inclu)
        }
    }

    list(func = funs, enum = enums, struct = structs, union = unions, type = types, file = files)
}

proc_type_funs <- function(types, funs) {
    if (is.null(funs)) return(NULL)

    returns <- list(id = unique(funs$returns))
    returns$type <- lapply(returns$id, find_basetype, types = types$all)
    funs$returns <- lapply(match(funs$returns, returns$id),
        function(ind) list(id = returns$id[ind], type = returns$type[ind])
    )

    args <- list(id = unique(unlist(
        lapply(funs$arguments, .subset2, "type"), FALSE, FALSE)
    ))
    args$type <- lapply(args$id, find_basetype, types = types$all)
    for (i in seq_len(nrow(funs))) {
        a <- funs$arguments[[i]]
        if (!NROW(a)) next
        if (is.data.frame(a)) {
            names(a)[2] <- "id"
        } else {
            names(a) <- "id"
        }
        a$type <- args$type[match(a$id, args$id)]
        funs$arguments[[i]] <- a
    }

    funs
}

proc_type_structs <- function(types, structs) {
    if (is.null(structs)) return(NULL)

    for (i in seq_along(structs$members)) {
        if (is.null(structs$members[[i]])) next

        structs$members[[i]]$type <- lapply(
            structs$members[[i]]$type, find_basetype, types = types$all
        )
    }

    structs
}

proc_type_unions <- function(types, unions) proc_type_structs(types, unions)

find_basetype <- function(types, id, depth = Inf) {
    type <- c()
    kind <- c()
    n <- 1L

    while (n <= depth) {
        ind <- match(id, types$id)
        if (is.na(ind)) return(list(name = NULL, type = c(), kind = c()))

        # this means that we did not reach base type, function pointer, enum,
        # struct, union
        if (!is.na(id <- types$type[ind])) {
            type <- c(type, types$name[ind])
            kind <- c(kind, types$kind[ind])
        } else {
            # After we reach those types, it is possible that the previous one
            # is a <Typedef/>.
            # In this case, remove the previous <Typedef/>
            if (length(kind) && !is.na(m <- match("def", kind))) {
                type <- type[-m]
                kind <- kind[-m]
            }
            type <- c(type, types$name[ind])
            kind <- c(kind, types$kind[ind])
            break
        }
        n <- n + 1L
    }

    list(type = type, kind = kind)
}

merge_all_types <- function(types, enums, structs, unions, fields) {
    types$all <- data.frame()

    if (!is.null(types$def)) {
        types$all <- rbind.data.frame(types$all,
            as_df(list(
                id = types$def$id, name = types$def$name,
                type = types$def$type, kind = "def"
            ))
        )
    }

    if (!is.null(enums)) {
        types$all <- rbind.data.frame(types$all,
            as_df(list(
                id = enums$id, name = sprintf("<%s>", enums$name),
                type = NA_character_, kind = "enum"
            ))
        )
    }

    if (!is.null(structs)) {
        types$all <- rbind.data.frame(types$all,
            as_df(list(
                id = structs$id, name = sprintf("<%s>", structs$name),
                type = NA_character_, kind = "struct"
            ))
        )
    }

    if (!is.null(unions)) {
        types$all <- rbind.data.frame(types$all,
            as_df(list(
                id = unions$id, name = sprintf("<%s>", unions$name),
                type = NA_character_, kind = "union"
            ))
        )
    }

    if (!is.null(types$base)) {
        types$all <- rbind.data.frame(types$all,
            as_df(list(
                id = types$base$id, name = types$base$name,
                type = NA_character_, kind = "base"
            ))
        )
    }

    if (!is.null(types$cvqualified)) {
        types$all <- rbind.data.frame(types$all,
            as_df(list(
                id = types$cvqualified$id,
                name = ifelse(types$cvqualified$const == "1", "const", ""),
                type = types$cvqualified$type, kind = "cvqualified"
            ))
        )
    }

    if (!is.null(types$atomic)) {
        types$all <- rbind.data.frame(types$all,
            as_df(list(
                id = types$atomic$id, name = "",
                type = types$atomic$type, kind = "atomic"
            ))
        )
    }

    if (!is.null(types$auto)) {
        types$all <- rbind.data.frame(types$all,
            as_df(list(
                id = types$auto$id, name = "",
                type = NA_character_, kind = "auto"
            ))
        )
    }

    if (!is.null(types$pointer)) {
        types$all <- rbind.data.frame(types$all,
            as_df(list(
                id = types$pointer$id,
                name = "*",
                type = types$pointer$type, kind = "pointer"
            ))
        )
    }

    if (!is.null(types$offset)) {
        types$all <- rbind.data.frame(types$all,
            as_df(list(
                id = types$offset$id, name = "",
                type = types$offset$type, kind = "offset"
            ))
        )
    }

    if (!is.null(types$reference)) {
        types$all <- rbind.data.frame(types$all,
            as_df(list(
                id = types$reference$id, name = "",
                type = types$reference$type, kind = "reference"
            ))
        )
    }

    if (!is.null(types$rvalueref)) {
        types$all <- rbind.data.frame(types$all,
            as_df(list(
                id = types$rvalueref$id, name = "",
                type = types$rvalueref$type, kind = "rvalueref"
            ))
        )
    }

    if (!is.null(types$array)) {
        types$all <- rbind.data.frame(types$all,
            as_df(list(
                id = types$array$id, name = "[]",
                type = types$array$type, kind = "array"
            ))
        )
    }

    if (!is.null(types$elaborated)) {
        # <ElaboratedType/> only exists in CastXML not gccxml.
        # Both 'keyword' and 'qualifier' attributes are optional.
        elab <- as_df(list(
            id = types$elaborated$id,
            name = types$elaborated$qualifier,
            type = types$elaborated$type,
            kind = types$elaborated$keyword
        ))
        elab$name[is.na(elab$name)] <- ""
        elab$kind[is.na(elab$kind)] <- "elaborated"

        types$all <- rbind.data.frame(types$all, elab)
    }

    if (!is.null(types$func)) {
        # all function types are function pointers
        ind <- match(types$func$id, types$pointer$type)

        # just in case
        if (any(mis <- is.na(ind))) {
            stop(spaste(
                "Found function types not defined as pointers: [%s]",
                .v = spaste("'%s'", .v = types$func[mis]),
                .vcoll = ", "
            ))
        }

        # there are only 2 possible ways that function pointers can appear:
        # a. in Typedef
        # b. as a member in Struct/Union
        members <- do.call(rbind.data.frame, c(structs$members, unions$members))
        types_tmp <- as_df(list(
            type = c(types$def$type, members$type),
            name = c(types$def$name, members$name)
        ))
        types$func$name <- types_tmp$name[match(types$pointer$id[ind], types_tmp$type)]
        types$func$name[is.na(types$func$name)] <- ""

        types$all <- rbind.data.frame(types$all,
            as_df(list(
                id = types$func$id, name = types$func$name,
                type = NA_character_, kind = "function"
            ))
        )

        # process argument and return types
        types$func <- proc_type_funs(types, types$func)[, c("id", "name", "returns", "arguments")]
    }

    types
}

proc_node_files <- function(xml) {
    node_attrs(xml, "File", c("id", "name"))
}

proc_node_fields <- function(xml) {
    node_attrs(xml, "Field", c("id", "name", "type", "context"))
}

proc_node_funs <- function(xml) {
    node_funs <- xml2::xml_find_all(xml, "Function")
    funs <- node_attrs(node_funs,
        attrs = c("id", "name", "returns", "context", "file", "static")
    )
    if (is.null(funs)) return(NULL)

    funs$static <- !is.na(funs$static)

    fun_args <- node_attrs(node_funs, "Argument", c("name", "type"), df = FALSE)
    funs$arguments <- lapply(fun_args, as_df)

    # check ellipsis
    node_dots <- xml2::xml_find_all(node_funs, "Ellipsis", flatten = FALSE)
    funs$ellipsis <- lengths(node_dots) > 0L

    funs
}

correct_struct_names <- function(structs, types) {
    # NOTE: It is possible that some enums/structs/unions have empty names
    #       in the XML. Should use Typedef to get the full names
    if (any(empty <- structs$name == "")) {
        # check to see if there are any elaborated types
        # If there are elaborated types, they should be used to find the actual
        # typedefs
        if (any(!is.na(types$elaborated$id))) {
            ind <- match(structs$id[empty], types$elaborated$type)
            # ignore mismatched
            empty[which(empty)[is.na(ind)]] <- FALSE
            structs$name[empty] <- types$def$name[match(types$elaborated$id[ind], types$def$type)]
            empty <- structs$name == ""
        }

        # check if there are still empty struct names
        # If yes, try match directly using typedefs
        if (any(empty)) {
            structs$name[empty] <- types$def$name[match(structs$id[empty], types$def$type)]
        }
    }
    structs
}

proc_node_enums <- function(xml, types) {
    node_enums <- xml2::xml_find_all(xml, "Enumeration")
    enums <- node_attrs(node_enums,
        attrs = c("id", "name", "context", "size", "align", "file")
    )
    if (is.null(enums)) return(NULL)

    enums <- correct_struct_names(enums, types)

    enums$size <- as.integer(enums$size)
    enums$align <- as.integer(enums$align)

    enum_vals <- node_attrs(node_enums, "EnumValue", c("name", "init"), df = FALSE)
    enums$values <- lapply(enum_vals, as_df)

    enums
}

proc_node_structs_unions <- function(xml, kind = c("struct", "union"), types, fields) {
    kind <- switch(match.arg(kind), struct = "Struct", union = "Union")
    structs <- node_attrs(xml, kind,
        c("id", "name", "context", "file", "members", "size", "align")
    )
    if (is.null(structs)) return(NULL)

    structs <- correct_struct_names(structs, types)

    structs$size <- as.integer(structs$size)
    structs$align <- as.integer(structs$align)

    # extract field info if not provided
    if (missing(fields) || NROW(fields)) fields <- proc_node_fields(xml)

    members <- strsplit(structs$members, " ", fixed = TRUE)
    for (i in seq_len(nrow(structs))) {
        if (length(mem <- members[[i]]) == 1L && is.na(mem)) {
            structs$members[i] <- list(NULL)
            next
        }

        ind <- match(mem, fields$id)
        ctx <- structs$id[[i]]

        if (any(mis <- is.na(ind))) {
            warning(spaste(
                "Ignore fields with no corresponding field data for struct '%s': ['%s']",
                .v = list(ctx, mem[mis]), .vcoll = ", "
            ))
            ind <- ind[!mis]
            mem <- mem[!mis]
        }

        if (any(mis <- fields$context[ind] != ctx)) {
            warning(spaste(
                "Ignoring field from mismatched context for struct '%s': ['%s' (ctx: '%s')]",
                .v = list(ctx, mem[mis], fields$context[ind][mis]), .vcoll = ", "
            ))
            ind <- ind[!mis]
            mem <- mem[!mis]
        }
        structs$members[i] <- list(as_df(list(
            id = fields$id[ind], name = fields$name[ind], type = fields$type[ind]
        )))
    }

    structs
}

proc_node_structs <- function(xml, types, fields) {
    proc_node_structs_unions(xml, "struct", types, fields)
}

proc_node_unions <- function(xml, types, fields) {
    proc_node_structs_unions(xml, "union", types, fields)
}

proc_node_types <- function(xml) {
    type_def <- node_attrs(xml, "Typedef", c("id", "name", "type"))

    type_base <- node_attrs(xml, "FundamentalType", c("id", "name", "size", "align"))

    type_cvqualified <- node_attrs(xml, "CvQualifiedType", c("id", "type", "const"))

    type_atomic <- node_attrs(xml, "AtomicType", c("id", "type"))

    type_atomic <- node_attrs(xml, "AutoType", c("id"))

    type_pointer <- node_attrs(xml, "PointerType", c("id", "type"))

    type_offset <- node_attrs(xml, "OffsetType", c("id", "type", "basetype"))

    type_reference <- node_attrs(xml, "ReferenceType", c("id", "type"))

    type_rvalueref <- node_attrs(xml, "RValueReferenceType", c("id", "type"))

    type_array <- node_attrs(xml, "ArrayType", c("id", "type"))

    type_elaborated  <- node_attrs(xml, "ElaboratedType",
        c("id", "type", "keyword", "qualifier")
    )

    node_funt <- xml2::xml_find_all(xml, "FunctionType")
    type_function <- node_attrs(node_funt, attrs = c("id", "returns"))
    if (!is.null(type_function)) {
        type_function$arguments <- node_attrs(node_funt, "Argument", "type", df = FALSE)
    }

    list(
        def         = type_def,
        base        = type_base,
        cvqualified = type_cvqualified,
        atomic      = type_atomic,
        pointer     = type_pointer,
        offset      = type_offset,
        reference   = type_reference,
        rvalueref   = type_rvalueref,
        array       = type_array,
        elaborated  = type_elaborated,
        func        = type_function
    )
}

proc_node_base <- function(xml) {
    base <- node_attrs(xml, "FundamentalType", c("id", "name", "size", "align"))

    basetype_map <- c(
        "B" = "_Bool",
        "c" = "char",
        "C" = "unsigned char",
        "s" = "short int",
        "S" = "short unsigned int",
        "i" = "int",
        "I" = "unsigned int",
        "j" = "long int",
        "J" = "long unsigned int",
        "l" = "long long int",
        "L" = "long long unsigned int",
        "f" = "float",
        "d" = "double",
        "p" = "pointer",
        "Z" = "string",
        "v" = "void"
    )

    base
}

node_attrs <- function(nodes, name = NULL, attrs = c("id", "name"), df = TRUE) {
    if (!is.null(name)) {
        nodes <- xml2::xml_find_all(nodes, name, flatten = FALSE)
    }
    if (!length(nodes)) return(NULL)

    if (is.null(attrs)) {
        attrs <- names(xml2::xml_attrs(nodes[[1]]))
        if (!length(attrs)) return(NULL)
    }

    if (is.null(names(attrs))) {
        names(attrs) <- attrs
    } else {
        names(attrs)[names(attrs) == ""] <- attrs[names(attrs) == ""]
    }

    res <- lapply(nodes, function(type) lapply(attrs, xml2::xml_attr, x = type))
    if (!df) res else as_df(transpose(res))
}
