#' Parse C-family header files using CastXML and gather data from the generated
#' XML.
#'
#' @param header A single string indicating the path of C header file.
#'
#' @param limit A flag (`TRUE`/`FALSE`) a string, or a character vector.
#'        If `TRUE`, only functions/enums/structs/unions from the directory of
#'        the input header are kept. If `FALSE`, no subsetting is performed.
#'        If a single string, it will be used as a regular expression to extract
#'        only functions/enums/structs/unions that match the pattern.
#'        If a character vector, it should be paths of directories used to
#'        constrain the scope.
#'        Default: `TRUE`.
#'
#' @param keep Either `TRUE` or `FALSE`. If `TRUE`, the XML file generated by
#'        CastXML is saved into the same directory of input header file with the
#'        same name. Default: `FALSE`.
#'
#' @param cflags A character vector of C compile flags passed to CastXML.
#'        Default: `NULL`.
#'
#' @param castxml A single string indicating the file path of the CastXML
#'        executable. Default is used the path found by [locate_castxml()].
#'
#' @return A named list.
#'
#' @export
port <- function(header, limit = TRUE, keep = FALSE, cflags = NULL, castxml = locate_castxml()) {
    if (!is_string(castxml) || !file.exists(castxml)) {
        stop("Argument 'castxml' must be a file path of CastXML executable.")
    }
    if (!is_string(header) || !file.exists(header)) {
        stop("Argument 'header' must be a file path.")
    } else if (file_ext(header) %in% c("hpp", "hh")) {
        warning(paste0(
            "Argument 'header' seems to be a C++ header file",
            "which is currently not fully supported. Parsing errors may occur."
        ))
    }
    if (!is.null(cflags) && (!is.character(cflags) || anyNA(cflags))) {
        stop("Argument 'cflags' should be NULL or a character vector without missing values.")
    }
    if (!is_flag(limit) && (!is.character(limit) || anyNA(limit))) {
        stop("Argument 'limit' should be either TRUE/FALSE or a character vector of directories.")
    }
    if (!is_flag(keep)) {
        stop("Argument 'keep' should be either TRUE or FALSE.")
    }

    castxml <- normalizePath(castxml, mustWork = TRUE)
    out <- tempfile("porter-", fileext = ".xml")

    # run castxml and read the generated XML file
    proc <- system3(castxml, "--castxml-output=1", cflags, "-o", out, header, .capture = FALSE)
    if (proc != 0L || !file.exists(out)) {
        stop("CastXML errors. Please check input arguments, especially 'header' and 'cflags'.")
    }

    if (keep) {
        file.copy(out, sprintf("%s.xml", tools::file_path_sans_ext(header)))
    }

    # get the directories for headers to be included
    dirs <- NULL
    pattern <- NULL
    # only consider files in the same folder as the input header file
    if (is_flag(limit) && limit) {
        dirs <- dirname(header)
    } else if (any(is_dir <- dir.exists(limit))) {
        dirs <- limit[is_dir]
    } else if (is_string(limit) && !is_dir) {
        # use limit as a regex
        pattern <- limit
    }
    data <- port_xml(out, dirs, pattern)

    data["file"] <- NULL
    data["type"] <- NULL

    # TODO: remove non-useful columns
    data
}

#' Extract data from the XML file generated by CastXML
#'
#' @param xml A path of an XML generated using CastXML. Both the
#'        `--castxml-output` and `--output-gccxml` options are supported.
#'
#' @param dirs A character of directories used to constrain the header files to
#'        extract the data. Default: `NULL`.
#'
#' @param pattern A regular expression. If not `NULL`, only
#'        functions/enums/structs/unions match that pattern is returned.
#'        Default: `NULL`.
#'
#' @return A named list of six elements:
#'
#' - `func`: function data
#' - `enum`: enumeration data
#' - `struct`: struct data
#' - `union`: union data
#' - `type`: type data
#' - `file`: file data
#'
#' @keywords internal
#' @export
port_xml <- function(xml, dirs = NULL, pattern = NULL) {
    if (!"xml_document" %in% class(xml)) xml <- xml2::read_xml(xml)

    # check if the root is GCC_XML or CastXML
    if (!xml2::xml_name(xml2::xml_root(xml)) %in% c("GCC_XML", "CastXML")) {
        stop("Input XML should be generated using GCCXML or CastXML.")
    }

    # extract data from corresponding xml nodes
    files   <- proc_node_files(xml)
    fields  <- proc_node_fields(xml)
    types   <- proc_node_types(xml)
    funs    <- proc_node_funs(xml)
    enums   <- proc_node_enums(xml,   types)
    structs <- proc_node_structs(xml, types, fields)
    unions  <- proc_node_unions(xml,  types, fields)

    # merge all type data to create a full list of types
    types <- merge_all_types(types, enums, structs, unions, fields)

    # find base types for all function arguments and return values
    funs <- proc_type_funs(types, funs)

    # find base types for all struct/union members
    structs <- proc_type_structs(types, structs)
    unions  <- proc_type_unions(types, unions)

    # only consider files in the same folder as the input header file
    if (!is.null(dirs)) {
        dirs <- normalizePath(dirs, mustWork = FALSE)
        paths <- normalizePath(dirname(files$name), mustWork = FALSE)
        is_tar <- logical(length(paths))
        for (d in dirs) is_tar <- is_parent_dir(d, paths) | is_tar
        inclu <- files$id[is_tar]

        # no matched
        if (!length(inclu)) {
            out <- replicate(6, data.frame())
            names(out) <- c("func", "enum", "struct", "union", "type", "file")
            return(out)
        } else {
            subset_by_file <- function(df, files) {
                if (!is.null(df)) as_df(df[df$file %in% files, ])
            }
            funs    <- subset_by_file(funs,    inclu)
            enums   <- subset_by_file(enums,   inclu)
            structs <- subset_by_file(structs, inclu)
            unions  <- subset_by_file(unions,  inclu)
            files   <- subset_by_file(files,   inclu)
        }
    }

    if (!is.null(pattern)) {
        if (!is_string(pattern)) stop("Argument 'pattern' should be a single string.")
        subset_by_pattern <- function(df, pattern) {
            if (!is.null(df)) as_df(df[grepl(pattern, df$name), ])
        }
        funs    <- subset_by_pattern(funs,    pattern)
        enums   <- subset_by_pattern(enums,   pattern)
        structs <- subset_by_pattern(structs, pattern)
        unions  <- subset_by_pattern(unions,  pattern)
    }

    list(func = funs, enum = enums, struct = structs, union = unions, type = types, file = files)
}

# exclude data from builtin which is automatically generated by clang
proc_node_builtin <- function(xml) {
    xml2::xml_attr(xml2::xml_find_first(xml, "File[@name='<builtin>']"), "id")
}

dyncall_sig <- function(type, empty = FALSE) {
    basetype_map <- c(
        "B" = "_Bool",
        "c" = "char",
        "C" = "unsigned char",
        "s" = "short int",
        "S" = "short unsigned int",
        "i" = "int",
        "I" = "unsigned int",
        "j" = "long int",
        "J" = "long unsigned int",
        "l" = "long long int",
        "L" = "long long unsigned int",
        "f" = "float",
        "d" = "double",
        "p" = "pointer",
        "Z" = "string",
        "v" = "void"
    )

    len <- length(type$kind)

    # no return
    if (len == 0L) return(if (empty) "v" else NA_character_) # void

    # If ends up with base type, then directly convert
    if (type$kind[len] == "base") {
        # the simplest case
        if (len == 1L) {
            bt <- names(basetype_map)[match(type$type, basetype_map)]
            if (is.na(bt)) {
                stop(spaste("Internal error: unsupported base type found ('%s').", .v = type$type))
            }
            return(bt)
        }

        # pointer of a base type
        if (len == 2L) {
            bt <- names(basetype_map)[match(type$type[[len]], basetype_map)]
            if (is.na(bt)) {
                stop(spaste("Internal error: unknown base type found ('%s').", .v = type$type[[len]]))
            }

            # *void
            if (type$type[[1L]] == "*") {
                if (bt == "v") return("p") else return(paste0("*", bt))
            # const int, etc.
            } else if (type$type[[1L]] == "const") {
                return(bt)
            }
        }

        tp <- sort(type$type)

        if (len == 3L) {
            # const char *
            if (identical(tp, c("*", "char", "const"))) {
                return("Z") # string
            } else if (tp[[1L]] == "*") {
                return("p") # pointer
            }
        }

        # const char **, return as pointer
        if (len == 4L && tp[[1L]] == "*") return("p") # pointer
    }

    if (!(type$kind[len] %in% c("enum", "struct", "union", "function"))) {
        stop(spaste(
            "Internal error: unsupported signature found ('%s'['%s'])",
            .v = list(type$type, type$kind), .vcoll = " "
        ))
    }

    # NOTE: only support function pointer
    if (type$kind[len] == "function") {
        if (any(!type$type[-len] %in% c("*", "[]", "const"))) {
            stop(spaste(
                "Internal error: found 'function'",
                "with an invalid qualifier ('%s'['%s']).",
                .v = list(type$type[-len], type$kind[-len]), .vcoll = " "
            ))
        }
        # directly return pointer type
        return("p")
    }

    # handle enums/structs/unions
    if (len == 1L) {
        type$type
    } else if (len == 2L) {
        if (type$type[[1L]] == "const") {
            type$type[[len]]
        } else if (type$type[[1L]] %in% c("*", "[]")) {
            paste0("*", type$type[[len]])
        } else {
            stop(spaste(
                "Internal error: found enum/struct/union",
                "with an invalid qualifier ('%s'['%s']).",
                .v = list(type$type[-len], type$kind[-len]), .vcoll = " "
            ))
        }
    } else if (len == 3L) {
        if (identical(sort(type$type[-len]), c("*", "const"))) {
            paste0("*", type$type[len])
        } else if (identical(type$type[-len], c("*", "*"))) {
            "p"
        } else {
            stop(spaste(
                "Internal error: found enum/struct/union",
                "with an invalid qualifier ('%s'['%s']).",
                .v = list(type$type[-len], type$kind[-len]), .vcoll = " "
            ))
        }
    } else {
        stop(spaste(
            "Internal error: failed to detect signature ('%s')",
            .v = list(type$type, type$kind), .vcoll = " "
        ))
    }
}

proc_type_funs <- function(types, funs) {
    if (is.null(funs)) return(NULL)

    returns <- list(id = unique(funs$returns))
    returns$type <- lapply(returns$id, find_basetype, types = types$all)
    funs$returns <- lapply(match(funs$returns, returns$id),
        function(ind) list(id = returns$id[ind], type = returns$type[ind])
    )

    args <- list(id = unique(unlist(
        lapply(funs$arguments, .subset2, "type"), FALSE, FALSE)
    ))
    args$type <- lapply(args$id, find_basetype, types = types$all)
    for (i in seq_len(nrow(funs))) {
        a <- funs$arguments[[i]]
        if (!NROW(a)) next
        if (is.data.frame(a)) {
            names(a)[2] <- "id"
        } else {
            names(a) <- "id"
        }
        a$type <- args$type[match(a$id, args$id)]
        funs$arguments[[i]] <- a
    }

    funs
}

proc_type_structs <- function(types, structs) {
    if (is.null(structs)) return(NULL)

    for (i in seq_along(structs$members)) {
        if (is.null(structs$members[[i]])) next

        structs$members[[i]]$type <- lapply(
            structs$members[[i]]$type, find_basetype, types = types$all
        )
    }

    structs
}

proc_type_unions <- function(types, unions) proc_type_structs(types, unions)

find_basetype <- function(types, id, depth = Inf) {
    type <- c()
    kind <- c()
    n <- 1L

    while (n <= depth) {
        ind <- match(id, types$id)
        if (is.na(ind)) return(list(name = NULL, type = c(), kind = c()))

        id <- types$type[ind]

        # After we reach those types, it is possible that the previous one
        # is a <Typedef/>.
        # In this case, remove the previous <Typedef/>
        if (length(kind) && !is.na(m <- match("def", kind))) {
            type <- type[-m]
            kind <- kind[-m]
        }

        type <- c(type, types$name[ind])
        kind <- c(kind, types$kind[ind])

        if (is.na(id)) break
        n <- n + 1L
    }

    # remove empty elaborated type
    if (any(rem <- kind == "elaborated" & type == "")) {
        type <- type[!rem]
        kind <- kind[!rem]
    }

    list(type = type, kind = kind)
}

merge_all_types <- function(types, enums, structs, unions, fields) {
    types$all <- data.frame()

    if (!is.null(types$def)) {
        types$all <- rbind.data.frame(types$all,
            df(
                id = types$def$id, name = types$def$name,
                type = types$def$type, kind = "def"
            )
        )
    }

    if (!is.null(enums)) {
        types$all <- rbind.data.frame(types$all,
            df(
                id = enums$id, name = sprintf("<%s>", enums$name),
                type = NA_character_, kind = "enum"
            )
        )
    }

    if (!is.null(structs)) {
        types$all <- rbind.data.frame(types$all,
            df(
                id = structs$id, name = sprintf("<%s>", structs$name),
                type = NA_character_, kind = "struct"
            )
        )
    }

    if (!is.null(unions)) {
        types$all <- rbind.data.frame(types$all,
            df(
                id = unions$id, name = sprintf("<%s>", unions$name),
                type = NA_character_, kind = "union"
            )
        )
    }

    if (!is.null(types$base)) {
        types$all <- rbind.data.frame(types$all,
            df(
                id = types$base$id, name = types$base$name,
                type = NA_character_, kind = "base"
            )
        )
    }

    if (!is.null(types$cvqualified)) {
        types$all <- rbind.data.frame(types$all,
            df(
                id = types$cvqualified$id,
                name = ifelse(types$cvqualified$const == "1", "const", ""),
                type = types$cvqualified$type, kind = "cvqualified"
            )
        )
    }

    if (!is.null(types$atomic)) {
        types$all <- rbind.data.frame(types$all,
            df(
                id = types$atomic$id, name = "",
                type = types$atomic$type, kind = "atomic"
            )
        )
    }

    if (!is.null(types$auto)) {
        types$all <- rbind.data.frame(types$all,
            df(
                id = types$auto$id, name = "",
                type = NA_character_, kind = "auto"
            )
        )
    }

    if (!is.null(types$pointer)) {
        types$all <- rbind.data.frame(types$all,
            df(
                id = types$pointer$id,
                name = "*",
                type = types$pointer$type, kind = "pointer"
            )
        )
    }

    if (!is.null(types$offset)) {
        types$all <- rbind.data.frame(types$all,
            df(
                id = types$offset$id, name = "",
                type = types$offset$type, kind = "offset"
            )
        )
    }

    if (!is.null(types$reference)) {
        types$all <- rbind.data.frame(types$all,
            df(
                id = types$reference$id, name = "",
                type = types$reference$type, kind = "reference"
            )
        )
    }

    if (!is.null(types$rvalueref)) {
        types$all <- rbind.data.frame(types$all,
            df(
                id = types$rvalueref$id, name = "",
                type = types$rvalueref$type, kind = "rvalueref"
            )
        )
    }

    if (!is.null(types$array)) {
        types$all <- rbind.data.frame(types$all,
            df(
                id = types$array$id, name = "[]",
                type = types$array$type, kind = "array"
            )
        )
    }

    if (!is.null(types$elaborated)) {
        # <ElaboratedType/> only exists in CastXML not gccxml.
        # Both 'keyword' and 'qualifier' attributes are optional.
        elab <- df(
            id = types$elaborated$id,
            name = types$elaborated$qualifier,
            type = types$elaborated$type,
            kind = types$elaborated$keyword
        )
        elab$name[is.na(elab$name)] <- ""
        elab$kind[is.na(elab$kind)] <- "elaborated"

        types$all <- rbind.data.frame(types$all, elab)
    }

    if (!is.null(types$func)) {
        # all function types are function pointers
        ind <- match(types$func$id, types$pointer$type)

        # just in case
        if (any(mis <- is.na(ind))) {
            stop(spaste(
                "Found function types not defined as pointers: [%s]",
                .v = spaste("'%s'", .v = types$func[mis]),
                .vcoll = ", "
            ))
        }

        # there are only 2 possible ways that function pointers can appear:
        # a. in Typedef
        # b. as a member in Struct/Union
        members <- do.call(rbind.data.frame, c(structs$members, unions$members))
        types_tmp <- df(
            type = c(types$def$type, members$type),
            name = c(types$def$name, members$name),
            file = c(types$def$file,
                fields$file[match(members$id, fields$id)]
            )
        )

        ind <- match(types$pointer$id[ind], types_tmp$type)
        types$func$name <- types_tmp$name[ind]
        types$func$file <- types_tmp$file[ind]
        types$func$name[is.na(types$func$name)] <- ""

        # check again and issue warnings if still no matched
        if (any(empty <- types$func$name == "")) {
            warning(spaste(
                "Failed to parse names for function pointers: %s.",
                .v = spaste("'%s'", .v = types$func$id[empty], .rcoll = ", ")
            ))
        }

        types$all <- rbind.data.frame(types$all,
            df(
                id = types$func$id, name = types$func$name,
                type = NA_character_, kind = "function"
            )
        )

        # process argument and return types
        types$func <- proc_type_funs(types, types$func)[, c("id", "name", "returns", "arguments")]
    }

    types
}

proc_node_files <- function(xml) {
    node_attrs(xml, "File", c("id", "name"))
}

proc_node_fields <- function(xml) {
    fields <- node_attrs(xml, "Field", c("id", "name", "type", "context", "file"))

    if (!is.null(fields)) {
        fields <- fields[
            # the following fields are generated by clang and do not have file
            # attributes
            !(
                is.na(fields$file) &
                fields$name %in% c("gp_offset", "fp_offset", "overflow_arg_area",
                    "reg_save_area", "isa", "flags", "str", "length")
            ),
        ]

        # exclude clang auto-generated data
        fields <- fields[!fields$file %in% proc_node_builtin(xml), ]
    }

    fields
}

proc_node_funs <- function(xml) {
    node_funs <- xml2::xml_find_all(xml, "Function")
    funs <- node_attrs(node_funs,
        attrs = c("id", "name", "returns", "context", "file", "static")
    )
    if (is.null(funs)) return(NULL)
    # exclude clang auto-generated data
    funs <- funs[!funs$file %in% proc_node_builtin(xml), ]

    fun_args <- node_attrs(node_funs, "Argument", c("name", "type"), df = FALSE)
    funs$arguments <- lapply(fun_args, function(args) {
        # it is possible that CastXML failed to extract argument names
        if (length(args$type) && anyNA(args$name)) {
            mis <- is.na(args$name)

            # use this letters to generate random argument names
            nms <- c("X", "Y", "Z", "U", "V", "W", "A", "B", "C")

            # reuse letters when necessary
            ind <- seq_len(sum(mis)) %% length(nms)
            ind[ind == 0L] <- length(nms)

            # make sure names are unique
            args$name[mis] <- setdiff(
                make.unique(c(args$name[!mis], nms[ind]), sep = "_"),
                args$name[!mis]
            )
        }
        as_df(args)
    })

    # check ellipsis
    node_dots <- xml2::xml_find_all(node_funs, "Ellipsis", flatten = FALSE)
    funs$ellipsis <- lengths(node_dots) > 0L

    # only include non-static functions
    funs <- funs[is.na(funs$static), ]
    funs$static <- NULL

    funs
}

correct_struct_names <- function(structs, types, fields = NULL) {
    # NOTE: It is possible that some enums/structs/unions have empty names
    #       in the XML. Should use Typedef to get the full names
    if (any(empty <- structs$name == "")) {
        # this is the gccxml output
        if (is.null(types$elaborated)) {
            ids <- structs$id
            ind <- which(empty)
        # check to see if there are any elaborated types
        # If there are elaborated types, this is the CastXML format.
        # The elaborated types should be used to find the actual typedefs
        } else {
            ind <- match(structs$id[empty], types$elaborated$type)
            if (anyNA(ind)) {
                stop(spaste(
                    "Internal error: found struct(s) without a elaborated type ('%s').",
                    .v = structs$id[empty][is.na(ind)], .vcoll = " "
                ))
            }
            ids <- types$elaborated$id
        }

        ind <- match(ids[ind], types$def$type)
        structs$name[which(empty)[!is.na(ind)]] <- types$def$name[ind[!is.na(ind)]]

        # check again and try to match using fields
        # this is the case when a struct is a field of another struct, e.g.:
        #
        # struct {
        #     struct {
        #         ...
        #     } ABC
        # }
        if (any(empty <- structs$name == "") && !is.null(fields)) {
            if (is.null(types$elaborated)) {
                ind <- which(empty)
            } else {
                ind <- match(structs$id[empty], types$elaborated$type)
            }
            ind <- match(ids[ind], fields$type)
            structs$name[which(empty)[!is.na(ind)]] <- fields$name[ind[!is.na(ind)]]
        }

        # check again and issue warnings if still no matched
        if (any(empty <- structs$name == "")) {
            warning(spaste(
                "Failed to parse names for structs/unions: %s.",
                .v = spaste("'%s'", .v = structs$id[empty], .rcoll = ", ")
            ))
        }
    }
    structs
}

proc_node_enums <- function(xml, types) {
    node_enums <- xml2::xml_find_all(xml, "Enumeration")
    enums <- node_attrs(node_enums,
        attrs = c("id", "name", "context", "size", "align", "file")
    )
    if (is.null(enums)) return(NULL)

    # exclude clang auto-generated data
    enums <- enums[!enums$file %in% proc_node_builtin(xml), ]

    # fill all enum names
    enums <- correct_struct_names(enums, types)

    enums$size <- as.integer(enums$size)
    enums$align <- as.integer(enums$align)

    enum_vals <- node_attrs(node_enums, "EnumValue", c("name", "init"), df = FALSE)
    enums$values <- lapply(enum_vals, as_df)

    enums
}

proc_node_structs_unions <- function(xml, kind = c("struct", "union"), types, fields) {
    kind <- switch(match.arg(kind), struct = "Struct", union = "Union")
    structs <- node_attrs(xml, kind,
        c("id", "name", "context", "file", "members", "size", "align")
    )
    if (is.null(structs)) return(NULL)

    # exclude clang auto-generated data
    structs <- structs[!structs$file %in% proc_node_builtin(xml), ]

    # fill all struct names
    structs <- correct_struct_names(structs, types, fields)

    # change size and align to integers
    structs$size <- as.integer(structs$size)
    structs$align <- as.integer(structs$align)

    # extract field info if not provided
    if (missing(fields) || NROW(fields)) fields <- proc_node_fields(xml)

    # get field member list
    members <- strsplit(structs$members, " ", fixed = TRUE)

    # cache for all structs and unions id/name
    # needed only when there are members that are another structs or unions
    structs_unions <- NULL

    for (i in seq_len(nrow(structs))) {
        # if there is no members, remove member data of that struct
        if (length(mem <- members[[i]]) == 1L && is.na(mem)) {
            structs$members[i] <- list(NULL)
            next
        }

        # get current struct id
        ctx <- structs$id[[i]]

        # try match members in all fields
        ind <- match(mem, fields$id)

        # handle the simple case where all members can be found in the fields
        if (!any(mis <- is.na(ind))) {
            # check if matched fields have mismatched context
            # should be a rare case
            if (any(wrg <- fields$context[ind] != ctx)) {
                stop(spaste(
                    "Internal error: found fields from mismatched context for",
                    "%s '%s' (id: '%s'): ['%s' (ctx: '%s')]",
                    .vcoll = ", ", .v = list(
                        tolower(kind), structs$name[i], ctx, mem[wrg],
                        fields$context[ind][wrg]
                    )
                ))
            }

            structs$members[i] <- list(df(
                id = mem, name = fields$name[ind], type = fields$type[ind]
            ))
        # NOTE: it is possible that structs contain struct/union fields or vice versa
        } else {
            # check if matched fields have mismatched context
            # should be a rare case
            if (any(wrg <- fields$context[ind[!mis]] != ctx)) {
                stop(spaste(
                    "Internal error: found fields from mismatched context for",
                    "%s '%s' (id: '%s'): ['%s' (ctx: '%s')]",
                    .vcoll = ", ", .v = list(
                        tolower(kind), structs$name[i], ctx, mem[!mis[wrg]],
                        fields$context[ind[!mis]][wrg]
                    )
                ))
            }

            # init
            nms <- tps <- rep(NA_character_, length(mem))

            nms[!mis] <- fields$name[ind[!mis]]
            tps[!mis] <- fields$type[ind[!mis]]

            # extract unions only when needed
            if (is.null(structs_unions)) {
                # TODO: processing structs needs unions data, and vice versa
                #       both struct and union node extractions have to run twice
                #       should find a more efficient approach
                kind_other <- switch(kind, Struct = "Union", Union = "Struct")
                unions <- node_attrs(xml, kind_other, c("id", "name"))
                unions <- correct_struct_names(unions, types, fields)

                structs_unions <- df(
                    id = c(structs$id, unions$id),
                    name = c(structs$name, unions$name)
                )
            }

            # match using both structs and unions
            ind_union <- match(mem[mis], structs_unions$id)

            # TODO: handle non-typedef'd enum within struct definition, e.g.:
            #
            # typedef struct {
            #   enum {A, B, C} kind;
            # } mystruct
            #
            # should be a rare case

            # stop if still no matched
            if (any(mis_union <- is.na(ind_union))) {
                stop(spaste(
                    "Internal error: found fields with no corresponding field data for",
                    "%s '%s' (id: '%s'): ['%s']",
                    .vcoll = ", ", .v = list(
                        tolower(kind), structs$name[i], ctx, mem[mis][mis_union]
                    )
                ))
            }

            # update member names
            nms[mis] <- structs_unions$name[ind_union]
            # use the struct/union id as the type
            tps[mis] <- structs_unions$id[ind_union]

            # If there are non-typedef'd struct/union inside, there will be two
            # same members:
            # (1) one for <Struct />, i.e. the non-typedef'd struct itself
            # (2) one for <Field /> which refers the above struct
            #
            # In this case, only keep the <Field /> element

            # the indices of which are nested structs/unions
            idx <- which(mis)
            # ids of the nested structs/unions
            pre <- structs_unions$id[ind_union]
            # ids of the following fields
            nxt <- tps[idx + 1L]
            # in case the type refers to an elaborated one
            if (!is.null(types$elaborated)) {
                nxt <- types$elaborated$type[match(nxt, types$elaborated$id)]
            }

            # check if there are no following fields
            if (any(no <- is.na(nxt))) {
                # ignore
                idx <- idx[!no]
                pre <- pre[!no]
                nxt <- nxt[!no]
            }

            # remove the duplicated <Struct />
            rem <- idx[which(pre == nxt)]
            if (length(rem)) {
                mem <- mem[-rem]
                nms <- nms[-rem]
                tps <- tps[-rem]
            }

            # update member data
            structs$members[i] <- list(df(id = mem, name = nms, type = tps))
        }
    }

    structs
}

proc_node_structs <- function(xml, types, fields) {
    proc_node_structs_unions(xml, "struct", types, fields)
}

proc_node_unions <- function(xml, types, fields) {
    proc_node_structs_unions(xml, "union", types, fields)
}

proc_node_types <- function(xml) {
    type_def <- node_attrs(xml, "Typedef", c("id", "name", "type", "file", "context"))
    # exclude clang auto-generated data
    if (!is.null(type_def)) type_def <- type_def[!type_def$file %in% proc_node_builtin(xml), ]

    type_base <- node_attrs(xml, "FundamentalType", c("id", "name", "size", "align"))

    type_cvqualified <- node_attrs(xml, "CvQualifiedType", c("id", "type", "const"))

    type_atomic <- node_attrs(xml, "AtomicType", c("id", "type"))

    type_atomic <- node_attrs(xml, "AutoType", c("id"))

    type_pointer <- node_attrs(xml, "PointerType", c("id", "type"))

    type_offset <- node_attrs(xml, "OffsetType", c("id", "type", "basetype"))

    type_reference <- node_attrs(xml, "ReferenceType", c("id", "type"))

    type_rvalueref <- node_attrs(xml, "RValueReferenceType", c("id", "type"))

    type_array <- node_attrs(xml, "ArrayType", c("id", "type"))

    type_elaborated  <- node_attrs(xml, "ElaboratedType",
        c("id", "type", "keyword", "qualifier")
    )

    node_funt <- xml2::xml_find_all(xml, "FunctionType")
    type_function <- node_attrs(node_funt, attrs = c("id", "returns"))
    if (!is.null(type_function)) {
        type_function$arguments <- node_attrs(node_funt, "Argument", "type", df = FALSE)
    }

    list(
        def         = type_def,
        base        = type_base,
        cvqualified = type_cvqualified,
        atomic      = type_atomic,
        pointer     = type_pointer,
        offset      = type_offset,
        reference   = type_reference,
        rvalueref   = type_rvalueref,
        array       = type_array,
        elaborated  = type_elaborated,
        func        = type_function
    )
}

node_attrs <- function(nodes, name = NULL, attrs = c("id", "name"), df = TRUE) {
    if (!is.null(name)) {
        nodes <- xml2::xml_find_all(nodes, name, flatten = FALSE)
    }
    if (!length(nodes)) return(NULL)

    if (is.null(attrs)) {
        attrs <- names(xml2::xml_attrs(nodes[[1]]))
        if (!length(attrs)) return(NULL)
    }

    if (is.null(names(attrs))) {
        names(attrs) <- attrs
    } else {
        names(attrs)[names(attrs) == ""] <- attrs[names(attrs) == ""]
    }

    res <- lapply(nodes, function(type) lapply(attrs, xml2::xml_attr, x = type))
    if (!df) res else as_df(transpose(res))
}
